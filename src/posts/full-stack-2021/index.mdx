---
title: My go to 2021 fullstack setup for developing web applications
slug: 2021-full-stack
date: 2021-05-10
featureImage: [feature_dark.png, feature_light.png]
images: [react.png, styled-components.png, tailwind.png]
excerpt: A quick but informative post on my go to technologies for 2021 including my favorite tools and libraries for frontend and backend development as well as fast and simple deployment.
currentRepo: "none"
tags: ["informative", "react"]
---

<section>

# Overview

Throughout my journey of fullstack development i've encountered my fair share of technologies that help aid me when developing web applications so I thought i'd share some of my top picks.

The three basic aspects of full stack development consist of 3 main sections, frontend, backend, and deployment. That being said in the interest of keeping things quick and interesting all of the sections will be available in the table of contents to be easily navigated to.

</section>

<section>

# Frontend

<CS variant="react">

## [React](https://reactjs.org/)

<Display iconOf="react" />

For me React is my go to javascript library for developing web applications
because of its advance component based structure as well as its provided
hooks that allow you easily to implement a multitude of things into your
components such as state. The development process for web applications as
never been easier.

<div>

### Components

Components are the building blocks of any React application, and a single
app usually consists of multiple components. A component is essentially a
piece of the user interface. React splits the UI into independent,
reusable parts that can be processed separately. Learn more about [components](https://reactjs.org/docs/components-and-props.html).

### JSX

By using JSX we can simply write the "HTML" we all know and love straight
into our javascript files, this allows for really quick development and
relives all of the nightmares of having separated HTML from our
Javascript. Learn more about [JSX](https://reactjs.org/docs/introducing-jsx.html).

### Virtual DOM

As defined by [Wikipedia](https://en.wikipedia.org/wiki/Virtual_DOM), "A
virtual DOM is a lightweight JavaScript representation of the DOM used in
declarative web frameworks such as React, Vue.js, and Elm.[1] Updating the
virtual DOM is comparatively faster than updating the actual DOM, since
nothing has to be rendered onto the screen." Basically this means that the
development process is super painless because we can develop with really
fast realtime updates and such.

### Libraries

One of Reacts game changers is its massive ecosystem of libraries to aid
you in your development process. Libraries can help with every aspect of
your project so you don't need to re-invent the wheel every time you add
new features. Some notable React libraries are, [React router](https://reactrouter.com/), [Tailwind CSS](https://tailwindcss.com/), and of course [Styled-components](https://styled-components.com/") & [Zustand](https://github.com/pmndrs/zustand) (my two personal favorites).

</div>

<div>

Here is a simple functional component in react. If you are familiar with javascript as well as HTML some parts of this component may look very familiar to you.

```jsx -r-[SimpleReactComponent.js]/copy/
import React from "react";

const SimpleReactComponent = () => {
  const name = "Paul Bokelman";
  return (
    <div>
      <h1>Hello World</h1>
      <p>My name is {name}!</p>
    </div>
  );
};

export default SimpleReactComponent;
```

The output of this component on the page is simply:

<img
  src={props.images[0].publicURL}
  alt="reactPreview"
  style={{
    width: "100%",
    height: "100%",
  }}
/>

</div>

</CS>

<CS variant="vite">

## [Vite](https://vitejs.dev/)

<Display iconOf="vite" />

Vite is a easy choice for me in most cases versus [create](https://reactjs.org/docs/create-a-new-react-app.html), [Next.js](https://nextjs.org/), [Gatsby](https://www.gatsbyjs.com/) (for smaller applications) because its just incredibly quick, I mean really
just look at this [clip](https://twitter.com/amasad/status/1355379680275128321) of a side by side comparison of create-react-app and Vite. Because Vite
is so quick it makes the developer experience and effort that much better.

<div>

### Esbuild

Under the hood Vite uses esbuild to pre-bundle packages and modules in
order to deliver that blazing fast speeds that it preforms at. The reason
this is so much faster than typical frameworks is because esbuild is built
in golang and not javascript which makes it just that much faster, I mean
look at these [bench marks](https://esbuild.github.io/). Learn
more about [esbuild](https://esbuild.github.io/).

### Native TS & JSX

Both Typescript and JSX are supported right out of the box with Vite, if
that wasn't enough get this, Vite also uses esbuild to transpile the
typescript and or jsx which means that it is about 20~30x faster than
vanilla transpilation. Learn more about Native [TS](https://vitejs.dev/guide/features.html#typescript) & [JSX](https://vitejs.dev/guide/features.html#jsx).

### Hot Module Replacement (HMR)

As per the
[docs](https://vitejs.dev/guide/features.html#hot-module-replacement),
"Frameworks with HMR capabilities can leverage the API to provide instant, precise
updates without reloading the page or blowing away application state." Basically
this means that the hot reload time after making changes whilst developing is incredibly
fast which makes working on the application much easier and more efficient. Learn
more about [HMR](https://vitejs.dev/guide/features.html#hot-module-replacement).

</div>

<div>

If you are familiar with create-react-app you will notice that the process to setting up vite is very similar. After setting up the application you can do anything you normally would just alot faster!

```bash [With npm]/copy/
npm init @vitejs/app
```

```bash [With yarn]/copy/
yarn create @vitejs/app
```

</div>

</CS>

<CS variant="styledcomponents">

## [Styled-components](https://styled-components.com/)

<Display iconOf="styledcomponents" />

By far my favorite library to use along side React is styled-components.
This library is very simple, basically styled-components allows you to write
javascript inside of css as well as create "styled" components (duh) which
are react components that have specific styles assigned to them.

<div>

### Props

Probably one of the nicest and most useful features of styled-components
is that you can pass them props to then use to do whatever you want with,
for example, if we passed a prop of red and set it to false then in the
styled component we could check the value of that prop and render the
color accordingly. If this example didn't make sense or you want to learn
more, [passing props in styled components](https://styled-components.com/docs/basics#passed-props).

### Inheritance

A key feature of styled-components is its simple inheritance approach.
With component inheritance inside of the styles it makes it really easy to
create a base component like a button then just apply colors or other
attributes in a separate component to those base styles without rewriting
them. This approach to styling really streamlines the development process.
Learn more about [inheritance](https://styled-components.com/docs/basics#extending-styles).

### Themes

Themes is a very useful feature that we can utilize with
styled-components. Themes allow us to create separate files with all our
colors, fonts, sizes, etc... and pass them to the theme-provider then like
magic, we can use those colors through props in all of our styled
components! Theming is especially useful when working on a large scale
project where you want to keep all of your style attributes consistent and
or organized to later use. Learn more about [themes](https://styled-components.com/docs/advanced#theming).

</div>

<div>

Here is a simple example of using inheritance from styled-components to first make a parent component then child components with different styles and attributes.

```jsx -r-[App.jsx]/copy/
import React from "react";
import styled from "styled-components";
function App() {
  const Button = styled.button`
    // Main button template
    color: #000000;
    font-size: 2rem;
    margin: 1rem;
    padding: 0.25rem 1rem;
    border: 3px solid #000000;
    border-radius: 8px;
    display: block;
  `;

  const BlueButton = styled(Button)`
    // child button
    color: #49b9ff;
    border-color: #49b9ff;
  `;

  const RedButton = styled(Button)`
    // child button
    color: #ffffff;
    border-color: transparent;
    background-color: #ff4949;
  `;

  const GreenButton = styled(Button)`
    // child button
    padding: 0.25rem 5rem;
    color: #57bd49;
    border-color: #57bd49;
  `;

  // rendering components
  return (
    <div>
      <Button>Button</Button>
      <BlueButton>Blue Button</BlueButton>
      <RedButton>Red Background Button</RedButton>
      <GreenButton>Long Green Button</GreenButton>
    </div>
  );
}

export default App;
```

The output of this component should look like this:

<img src={props.images[1].publicURL} alt="styledcomponents" />

</div>

</CS>

<CS variant="tailwind">

## [Tailwind](https://github.com/pmndrs/zustand)

<Display iconOf="tailwind" />

Tailwind is one of the newer additions to my list of favorite tech and for good reason. Tailwind css is referred to as a "utility-first" css framework that very basically provides thousands of helper classes with uniform styles to speed up your development exponentially. This being said I have found tailwind to be an amazing tool both in productivity as well as enjoyability when working on any sized project.

<div>

### Ultimate flexibility

When you first install tailwind one thing it does is completely get rid of all basic styling applied to regular HTML elements. This is done in order to not have to override existing styles but because of this you can start on a completely blank slate and by using the wide variety of helper classes you can customize anything the way you like.

### Predefined design system

One thing that makes tailwind so powerful is that it has a very polished design system. Now this may not seem very important at first thought but when you get to use tailwind it really shows. With a predefined design system every class is catered towards a certain style so when you are building your application all the colors fit in together, the sizings look clean and proportional, etc.

### Great documentation

Tailwinds documentation is some of the best documentation I have ever seen for a framework, even if you are new to tailwind or have been using it for a while the documentation will always be a useful resource. Check out the [documentation](https://tailwindcss.com/docs).

</div>

<div>

Getting started with tailwind is very simple, although setup instructions may differ depending on different frameworks, I will be using vite. With vite the installation process if very easy, all we need to do is run 2 commands and add 3 lines of code.

First install the dependencies:

```bash
npm install -D tailwindcss@latest postcss@latest autoprefixer@latest
```

Next, generate the `tailwind.config.js` and `postcss.config.js` files:

```bash
npx tailwindcss init -p
```

Then in your main css file (attached to root file) include:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Now you can use tailwind anywhere in your application (without imports). Using tailwind is very simple, you simply use it as you would any regular css class. You can check out the documentation on tailwind to learn all of the different class names and conventions but here is a simple preview of tailwind in action with React.

```jsx -r-[App.jsx]/copy/
import React, { useState } from "react";
import { CgSpinner } from "react-icons/cg";
function App() {
  const [loading, setLoading] = useState(false);
  return (
    <div className="h-screen bg-indigo-300 flex justify-center items-center">
      <button
        onClick={() => {
          setLoading(true);
          setTimeout(() => {
            setLoading(false);
          }, 1000);
        }}
        type="submit"
        disabled={loading ? true : false}
        className="mt-4 w-44 flex-none bg-indigo-600 hover:bg-indigo-700 text-white text-lg 
        leading-6 font-semibold py-2 px-6 border border-transparent rounded-xl focus:ring-2
        focus:ring-offset-2 focus:ring-offset-indigo-300 focus:ring-indigo-700 
        focus:outline-none transition-colors duration-200"
      >
        {loading ? (
          <CgSpinner className="animate-spin inline h-5 w-5 relative -top-0.5" />
        ) : (
          "Submit"
        )}
      </button>
    </div>
  );
}

export default App;
```

Below is just an image of the output although if you were to run the component yourself you'd see tailwinds simple animation library in action through the spinner icon.

<img src={props.images[2].publicURL} alt="tailwindPreview" />

</div>

</CS>

<CS variant="zustand">

## [Zustand](https://github.com/pmndrs/zustand)

<Display iconOf="zustand" />

Zustand is a very lightweight state management library that can easily be
scaled to any size of project you have. Zustand is one of my go to libraries
because of how simple the api and because of how simple and intuitive it is
to learn.

<div>

### Simple API

Zustand's api is very simple to understand, basically all you have to do
to get started with is to set up a store with the `create`
function then just enter the state variables in the object. You can then
simply get your store function and change the state however you'd like in
your component because there is no wrapping provider necessary. Learn more
about the [Zustand API](https://github.com/pmndrs/zustand#first-create-a-store).

### No providers

Unlike other state management solutions such as Reacts own [Context API](https://reactjs.org/docs/context.html), Zustand doesn't need to have all the children receiving the state to be wrapped in a context provider. This makes Zustand incredibly simple and flexible
because its just 1 less thing you have to worry about.

### Transient updates

Transient updates are a really cool and simple feature of Zustand,
basically what this means is that with large amounts of state changes the
component won't need to re-render with each state change. Learn more about [transient updates](https://github.com/pmndrs/zustand#transient-updates-for-often-occuring-state-changes).

</div>

<div>

If you want to learn more about Zustand check out my [post](/theme-switcher) on creating a simple theme switcher with zustand and styled-components!

</div>

</CS>

<CS variant="reactquery">

## [React-Query](https://react-query.tanstack.com/)

<Display iconOf="reactquery" />

React-query is the newest edition to my stack, at first I didn't see the importance of it but after using it for some projects I can't live without it. This very special library makes it as easy as can be to manage remote data through its advance hooks and features.

<div>

### Simple

Thanks to the developers, React-Query is actually very simple to get started with. All you have to do is wrap your application the the React-Query context provider, then use the `useQuery` or `useMutation` hooks where ever you'd like. These hooks are also very simple, for example the `useQuery` hook can simply be used like this:

```js
const { data, isLoading, error } = useQuery("getUsers", () =>
  // "getUsers" is name of query
  axios.get("https://jsonplaceholder.typicode.com/users")
); // fetch method and route

// display users names
data.map((user) => {
console.log(user.name);
}
```

### Advance synchronization

One of the biggest pains when working with regular requests is that when displaying it the data may be outdated at times, React-Query solves this. As per custom configuration React-Query will refetch data, you can also manually refetch data with the `refetch()` function.

### Automatic caching

Something that is notoriously difficult when fetching your data without the help of libraries is caching the previous or incoming data and checking to see if specific data should be updated to favor performance. React-Query makes this very simple by literally automatically caching data in order to make your application much quicker and more enjoyable to use.

</div>

<div>

React-Query is a very big topic so if you'd like to learn more check out the [documentation](https://react-query.tanstack.com/overview).

</div>

</CS>

</section>

<section>

# Backend

<CS variant="node">

## [Node](https://nodejs.org/en/)

<Display iconOf="node" />

Without a doubt Node is one of the most important pieces of technology for
web development although did you know that it can make backend development
really simple? Typically setting up a node server is moderately tedious
process although with the help of
[Express](https://expressjs.com/) this process is made much
more enjoyable and easy. Simply due to how simple the whole process of
setting up a server is as well as the flexibility, Node is my number one
pick for backend development.

<div>

### Fast

Since Node is built off of Chrome's V8 JavaScript engine it is incredibly fast in executing code. On top of being built on the V8 engine, Node is also event driven and asynchronous this means that promises or incoming api data can be run in parallel which means that Node does not need to wait for a single request.

### [Express](https://expressjs.com/)

One of the big perks of using Node is that you have access to Express. Express is a very powerful yet minimalist javascript framework for Node that allows for very fast development whilst also allowing the developer to have all the freedom they want. Check out the third page of this section to see an example.

### [Sequelize](https://sequelize.org/)

Another great thing about Node is that you can use sequelize. As described on their website, Sequelize is a promise-based, Node.js ORM (Object-relational mapping) for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server. This means that we can built and manipulate databases very easy through Node.

</div>

<div>

Setting up a basic Node server is incredibly easy, first make a new folder then initialize the project and install the required dependencies. When you first initialize the project you will be prompted with lots of questions, after naming your project (first question) you can simply click enter on all of the rest.

```bash
mkdir nodeServer && cd nodeServer && npm init && npm install express
```

At this point we have installed of the required dependencies and can jump into the code and start configuring the project. We need to first create a javascript file named `index.js` in the root of the project, this file will contain our server code and will run when we start the program.

Although in order to run the file through npm scripts we need to make a simple change to the `package.json`.

```json -r-{7}[package.json]/copy/
{
  "name": "myserver",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.17.1"
  }
}
```

Now whenever we run the `npm start` command the script will run our `index.js` file with node and allow us to properly execute it. With that out of the way we can jump into the `index.js` file.

We can set up a very simple server with just 8 lines of code.

```js -r-[index.js]/copy/
const express = require("express"); // importing express
const app = express(); // using express through declaration

app.get("/", (req, res) => {
  // setting up a simple get route with route of "/"
  res.send("Hello World!"); // when "/" is accessed the server will display "Hello World!"
});

app.listen(3000, () => {
  // server location
  console.log("Server is running"); // confirmation that server is running
});
```

Our simple server will now display "Hello World!" on the screen whenever the root route is accessed, check it out [http://localhost:3000/](http://localhost:3000).

This is an example of a very simple server although node has many things to offer one of which being route params.

```js -r-{8-11}[index.js]/copy/
const express = require("express");
const app = express();

app.get("/", (req, res) => {
  res.send("Hello World!");
});

app.get("/param/:myparam", (req, res) => {
  // colon notation represents a param, this means that "myparam" can be anything
  const param = req.params.myparam; // setting variable to param for simplicity
  res.send(`Your param is "${param}"`); // displaying param in response
});

app.listen(3000, () => {
  console.log("Server is running");
});
```

At this point if you went to [http://localhost:3000/param/check out my param](http://localhost:3000/param/check%20out%20my%20param) you would see "Your param is "check out my param"" displayed on the screen.

If you'd like to learn more about Node be sure to look out for my upcoming post on using Node, Express, and Sequelize together to make a full fledged REST api.

</div>

</CS>

<CS variant="firebase">

## [Firebase](https://firebase.google.com/)

<Display iconOf="firebase" />

Although firebase has a plethora of features to offer for mobile and web development, for backend web development I find [Firestore](https://firebase.google.com/docs/firestore) a very close competitor to the likes of Node with sequelize. Firestore is a flexible and scalable NoSQL cloud database to store and sync data for client and server-side development. This means that all you need to do in order to set up a very simple database is to simply use the api, nothing else. This is what makes firestore so powerful, the fact that there is a very low learning curve and that its infinitely scalable.

<div>

[Key Features](https://firebase.google.com/docs/firestore) referenced from documentation.

## Flexibility

The Cloud Firestore data model supports flexible, hierarchical data structures. Store your data in documents, organized into collections. Documents can contain complex nested objects in addition to subcollections.

## Expressive querying

In Cloud Firestore, you can use queries to retrieve individual, specific documents or to retrieve all the documents in a collection that match your query parameters. Your queries can include multiple, chained filters and combine filtering and sorting. They're also indexed by default, so query performance is proportional to the size of your result set, not your data set.

## Realtime updates

Like Realtime Database, Cloud Firestore uses data synchronization to update data on any connected device. However, it's also designed to make simple, one-time fetch queries efficiently.

## Offline support

Cloud Firestore caches data that your app is actively using, so the app can write, read, listen to, and query data even if the device is offline. When the device comes back online, Cloud Firestore synchronizes any local changes back to Cloud Firestore.

## Designed to scale

Cloud Firestore brings you the best of Google Cloud's powerful infrastructure: automatic multi-region data replication, strong consistency guarantees, atomic batch operations, and real transaction support. We've designed Cloud Firestore to handle the toughest database workloads from the world's biggest apps.

</div>

<div>

There is no reason the re-invent the wheel so if you would like to learn more about getting started check out the superb [documentation](https://firebase.google.com/docs/firestore/quickstart).

</div>

</CS>

</section>

<section>

# Deployment

<CS variant="netlify">

## [Netlify](https://www.netlify.com/)

<Display iconOf="netlify" />

In my mind there will never be an easier deployment process than that of netlify,
not only is it incredibly fast they also offer a very generous amount of space when
working on their free plan. Because of Netlifys Git-based workflow all you have to
do to deploy a project is to simply login with your github and chose the repo, then
your project will then be hosted on a public domain, seriously. Netlify also offers
[Netlify Edge](https://www.netlify.com/products/edge/) and [Netlify Functions](https://www.netlify.com/products/functions/)
but we will get more into that in the key features section.

<div>

### Blazing fast deployments

As previously mentioned Netlify makes deploying projects to the web incredibly simple, its as simple as literally clicking 2 buttons after you've logged in. On top of this after deploying your project will be hosted on a prefix of Netlifys domain which means that it is accessible to anyone to see, so prototyping web applications to the public or for a small project is very easy.

### Edge

Learn more about [Edge](https://www.netlify.com/products/edge/).

### Functions

Learn more about [Functions](https://www.netlify.com/products/functions/).

</div>

<div>

There really isn't any code to show for the deployment process because it is through github and so simple.

</div>

</CS>

</section>
